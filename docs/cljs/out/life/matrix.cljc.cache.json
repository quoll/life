["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ ","~$add","~$clojure.core.matrix","~$mget","^6","~$array","^6","~$emap","^6","~$compute-matrix","^6","~$shape","^6"],"~:excludes",["~#set",[]],"~:name","~$life.matrix","~:imports",null,"~:requires",["^ ","^6","^6"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","^5","^6","^7","^6","^8","^6","^9","^6","^:","^6","^;","^6"],"~:defs",["^ ","~$nbool",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/pgearon/dev/public/life/src/life/matrix.cljc","~:line",6,"~:column",7,"~:end-line",6,"~:end-column",12,"~:arglists",["~#list",["~$quote",["^N",[["~$f"]]]]],"~:doc","Create a function from a boolean function, mapping a truthy value to 1 or 0.\n   e.g. ((nbool not) false) => 1\n        ((nbool not) true) => 0"],"^>","~$life.matrix/nbool","~:variadic",false,"^H","src/life/matrix.cljc","^L",12,"~:method-params",["^N",[["~$f"]]],"~:protocol-impl",null,"~:arglists-meta",["^N",[null,null]],"^J",1,"^I",6,"^K",6,"~:max-fixed-arity",1,"~:fn-var",true,"^M",["^N",["^O",["^N",[["~$f"]]]]],"^P","Create a function from a boolean function, mapping a truthy value to 1 or 0.\n   e.g. ((nbool not) false) => 1\n        ((nbool not) true) => 0"],"~$takeof",["^ ","^F",null,"^G",["^ ","^H","/Users/pgearon/dev/public/life/src/life/matrix.cljc","^I",12,"^J",7,"^K",12,"^L",13,"^M",["^N",["^O",["^N",[["~$sh","~$a"],["^Y","~$a","~$default"]]]]],"^P","Creates a matrix of a given shape that contains a given matrix 'a'.\n   If the new matrix is smaller than the source matrix, then the source\n   matrix is truncated.\n   If the new matrix is larger than the source matrix in any dimension,\n   then it is padded out using the 'default' value, or 0 if not provided.","~:top-fn",["^ ","^R",false,"^V",3,"^S",["^N",[["^Y","~$a"],["^Y","~$a","^Z"]]],"^M",["^N",[["^Y","~$a"],["^Y","~$a","^Z"]]],"^U",["^N",[null,null]]]],"^>","~$life.matrix/takeof","^R",false,"^H","src/life/matrix.cljc","^L",13,"^[",["^ ","^R",false,"^V",3,"^S",["^N",[["^Y","~$a"],["^Y","~$a","^Z"]]],"^M",["^N",[["^Y","~$a"],["^Y","~$a","^Z"]]],"^U",["^N",[null,null]]],"^S",["^N",[["^Y","~$a"],["^Y","~$a","^Z"]]],"^T",null,"^U",["^N",[null,null]],"^J",1,"^I",12,"^K",12,"^V",3,"^W",true,"^M",["^N",[["^Y","~$a"],["^Y","~$a","^Z"]]],"^P","Creates a matrix of a given shape that contains a given matrix 'a'.\n   If the new matrix is smaller than the source matrix, then the source\n   matrix is truncated.\n   If the new matrix is larger than the source matrix in any dimension,\n   then it is padded out using the 'default' value, or 0 if not provided."],"~$and*",["^ ","^F",null,"^G",["^ ","^H","/Users/pgearon/dev/public/life/src/life/matrix.cljc","^I",27,"^J",7,"^K",27,"^L",11,"^M",["^N",["^O",["^N",[["~$a","~$b"]]]]],"^P","Performs an element-wise boolean AND operation on matrices\n   using numerical boolean values (0/1)"],"^>","~$life.matrix/and*","^R",false,"^H","src/life/matrix.cljc","^L",11,"^S",["^N",[["~$a","~$b"]]],"^T",null,"^U",["^N",[null,null]],"^J",1,"^I",27,"^K",27,"^V",2,"^W",true,"^M",["^N",["^O",["^N",[["~$a","~$b"]]]]],"^P","Performs an element-wise boolean AND operation on matrices\n   using numerical boolean values (0/1)"],"~$or*",["^ ","^F",null,"^G",["^ ","^H","/Users/pgearon/dev/public/life/src/life/matrix.cljc","^I",32,"^J",7,"^K",32,"^L",10,"^M",["^N",["^O",["^N",[["~$a","~$b"]]]]],"^P","Performs an element-wise boolean OR operation on matrices\n   using numerical boolean values (0/1)"],"^>","~$life.matrix/or*","^R",false,"^H","src/life/matrix.cljc","^L",10,"^S",["^N",[["~$a","~$b"]]],"^T",null,"^U",["^N",[null,null]],"^J",1,"^I",32,"^K",32,"^V",2,"^W",true,"^M",["^N",["^O",["^N",[["~$a","~$b"]]]]],"^P","Performs an element-wise boolean OR operation on matrices\n   using numerical boolean values (0/1)"],"~$outer",["^ ","^F",null,"^G",["^ ","^H","/Users/pgearon/dev/public/life/src/life/matrix.cljc","^I",37,"^J",7,"^K",37,"^L",12,"^M",["^N",["^O",["^N",[["~$a","~$b"]]]]],"^P","Creates an outer product of 2 sequences. The elements of the product\n   are stored in a record with keys :a :b. Ideally these would be a\n   2-element vector, but matrix operations treat such vectors as a new\n   dimension."],"^>","~$life.matrix/outer","^R",false,"^H","src/life/matrix.cljc","^L",12,"^S",["^N",[["~$a","~$b"]]],"^T",null,"^U",["^N",[null,null]],"^J",1,"^I",37,"^K",37,"^V",2,"^W",true,"^M",["^N",["^O",["^N",[["~$a","~$b"]]]]],"^P","Creates an outer product of 2 sequences. The elements of the product\n   are stored in a record with keys :a :b. Ideally these would be a\n   2-element vector, but matrix operations treat such vectors as a new\n   dimension."],"~$outer-fn",["^ ","^F",null,"^G",["^ ","^H","/Users/pgearon/dev/public/life/src/life/matrix.cljc","^I",48,"^J",7,"^K",48,"^L",15,"^M",["^N",["^O",["^N",[["~$f","~$x","~$y"]]]]],"^P","Creates a function based on applying f bound to a single argument,\n   across remaining arguments that are the outer product of x and y."],"^>","~$life.matrix/outer-fn","^R",false,"^H","src/life/matrix.cljc","^L",15,"^S",["^N",[["~$f","~$x","~$y"]]],"^T",null,"^U",["^N",[null,null]],"^J",1,"^I",48,"^K",48,"^V",3,"^W",true,"^M",["^N",["^O",["^N",[["~$f","~$x","~$y"]]]]],"^P","Creates a function based on applying f bound to a single argument,\n   across remaining arguments that are the outer product of x and y."],"~$=x",["^ ","^F",null,"^G",["^ ","^H","/Users/pgearon/dev/public/life/src/life/matrix.cljc","^I",56,"^J",7,"^K",56,"^L",9,"^M",["^N",["^O",["^N",[["~$a"]]]]],"^P","Creates a function from a matrix, that when a applied to a scalar will\n   return a boolean matrix where every matrix element that matches the\n   scalar will be true (1) in the result.\n   e.g. ((=x [1 2 3]) 2) => [0 1 0]\n        ((=x [1 2 3]) 3) => [0 0 1]"],"^>","~$life.matrix/=x","^R",false,"^H","src/life/matrix.cljc","^L",9,"^S",["^N",[["~$a"]]],"^T",null,"^U",["^N",[null,null]],"^J",1,"^I",56,"^K",56,"^V",1,"^W",true,"^M",["^N",["^O",["^N",[["~$a"]]]]],"^P","Creates a function from a matrix, that when a applied to a scalar will\n   return a boolean matrix where every matrix element that matches the\n   scalar will be true (1) in the result.\n   e.g. ((=x [1 2 3]) 2) => [0 1 0]\n        ((=x [1 2 3]) 3) => [0 0 1]"],"~$power",["^ ","^F",null,"^G",["^ ","^H","/Users/pgearon/dev/public/life/src/life/matrix.cljc","^I",65,"^J",7,"^K",65,"^L",12,"^M",["^N",["^O",["^N",[["~$f","~$n"]]]]]],"^>","~$life.matrix/power","^R",false,"^H","src/life/matrix.cljc","^L",12,"^S",["^N",[["~$f","~$n"]]],"^T",null,"^U",["^N",[null,null]],"^J",1,"^I",65,"^K",65,"^V",2,"^W",true,"^M",["^N",["^O",["^N",[["~$f","~$n"]]]]]],"~$power-limit",["^ ","^F",null,"^G",["^ ","^H","/Users/pgearon/dev/public/life/src/life/matrix.cljc","^I",70,"^J",7,"^K",70,"^L",18,"^M",["^N",["^O",["^N",[["~$f","~$a"]]]]],"^P","Finds the fixpoint of a function starting at a given argument.\n   The function is repeatedly applied to the result of the previous application\n   until the result from the function is the same as the argument that led to it.\n   e.g. (power-limit #(min (inc %) 10) 1) => 10"],"^>","~$life.matrix/power-limit","^R",false,"^H","src/life/matrix.cljc","^L",18,"^S",["^N",[["~$f","~$a"]]],"^T",null,"^U",["^N",[null,null]],"^J",1,"^I",70,"^K",70,"^V",2,"^W",true,"^M",["^N",["^O",["^N",[["~$f","~$a"]]]]],"^P","Finds the fixpoint of a function starting at a given argument.\n   The function is repeatedly applied to the result of the previous application\n   until the result from the function is the same as the argument that led to it.\n   e.g. (power-limit #(min (inc %) 10) 1) => 10"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^6","^6"],"~:cljs.analyzer/constants",["^ ","~:seen",["^=",["~:b","~:a"]],"~:order",["~:a","~:b"]],"^P","Implements functionality to duplicate APL operations used in Life"]